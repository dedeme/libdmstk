// Copyright 25-Sep-2019 ÂºDeme
// GNU General Public License - V3 <http://www.gnu.org/licenses/>

300 klen =
/// Int
/// Standard keys length.

2592000 tNoExpiration. = // seconds == 30 days

"nkXliX8lg2kTuQSS/OoLXCk8eS4Fwmc+N7l6TTNgzM1vdKewO0cjok51vcdl"
"OKVXyPu83xYhX6mDeDyzapxL3dIZuzwyemVw+uCNCZ01WDw82oninzp88Hef" +
"bn3pPnSMqEaP2bOdX+8yEe6sGkc3IO3e38+CqSOyDBxHCqfrZT2Sqn6SHWhR" +
"KqpJp4K96QqtVjmXwhVcST9l+u1XUPL6K9HQfEEGMGcToMGUrzNQxCzlg2g+" +
"Hg55i7iiKbA0ogENhEIFjMG+wmFDNzgjvDnNYOaPTQ7l4C8aaPsEfl3sugiw" + dmKey. =

{} map,from Cgi. =
/*
  fkey: String     // key to encrypt files
  key: Opt<String> // key to communications.
  home: String;
  tExpiration: Int
*/

( @+si:: tExpiration =; home =

  this,Cgi.
    "fkey"        : this,dmKey. this,dmKey. str,len cryp,key : map,put+
    "key"         : wrap,none : map,put+
    "home"        : home : map,put+
    "tExpiration" : tExpiration : map,put

  home file,exists? ! (home file,mkdir) if

  home "users.db" path,+ file,exists? !
  (
    [] data this,writeUsers.
    "admin" this,dmKey. "0" this,putUser.
    [] data this,writeSessions.
  )
  if
@-) init =>
/// @si -> @

// Users -----------------------------------------------------------------------

( Users =  // (List<String>) -> Void
  this,Cgi. .home : "users.db" : path,+
    Users (js,ws) lst,map js,wa : this,Cgi. .fkey : cryp,cryp
      file,write
) writeUsers. =>

( // () -> List<String>
  this,Cgi. .home : "users.db" : path,+
  file,read
    this,Cgi. .fkey cryp,decryp
    js,ra
    (js,rs) lst,map
) readUsers. =>

( id =; Users =  // (List<String>, String) -> Void
  Users (u =; u ":" str,split !0 id ==) lst,index : ix =
  ix -1 != (Users ix lst,remove) if
) removeUser. =>

( level =; key =; id =  // (String, String, String) -> Void
  this,readUsers. Users =
  Users id this,removeUser.
  Users
    id : ":" : key this,klen cryp,key : ":" : level + + + + lst,push+
    this,writeUsers.
) putUser. =>

( id =   // (String) -> Void
  this,readUsers.
  dup id this,removeUser.
  this,writeUsers.
) delUser. =>

( key =; id =   // (String, String) -> Opt<String>  Returns user level
  key this,klen cryp,key : kkey =
  this,readUsers. : Users =

  Users (":" str,split !0 id ==) lst,find
  ( ":" str,split Fields =;
    Fields !1 kkey == (Fields !2 wrap,some) (wrap,none) elif
  )
  ( wrap,none)
  wrap,option
) checkUser. =>

( level =; id =   // (String, String) -> Int
  [0] data : Changed =
  this,readUsers.
    ( u =;
      u ":" str,split : Ds =;

      Ds !0 id ==
      (
        Changed 1 <<
        Ds !0 : ":" : Ds !1 : ":" : level + + + +
      )
      ( u)
      elif
    )
    lst,map this,writeUsers.
  Changed >>
) changeLevel. =>

( newPass =; oldPass =; id =  // (String, String, String) -> Int
  newPass this,klen cryp,key : newPassK =
  oldPass this,klen cryp,key : oldPassK =

  0 wrap,ref : Changed =
  this,readUsers.
    ( u =;
      u ":" str,split : Ds =;

      Ds !0 id == : Ds !1 oldPassK == : &&
      (
        Changed 1 <<
        Ds !0 : ":" : newPassK : ":" : Ds !2 : + + + +
      )
      ( u)
      elif
    )
    lst,map this,writeUsers.
  Changed >>
) changePass. =>

// Sessions --------------------------------------------------------------------

( Sessions =  // (List<Js>) -> Void  . Js is a JSON array
  this,Cgi. .home : "sessions.db" : path,+
    Sessions js,wa : this,Cgi. .fkey : cryp,cryp
  file,write
) writeSessions. =>

(   // () -> List<Js>. Js is a JSON array
  this,Cgi. .home : "sessions.db" : path,+
  file,read : this,Cgi. .fkey : cryp,decryp : js,ra
) readSessions. =>

( expiration =; comKey =; id =; sessionId =
    // (String, String, String, Int) -> Void
    // If expiration is 0 tNoExpiration is used
  expiration (expiration) (this,tNoExpiration.) elif : lapse =
  time,now lapse time,add : tm =

  this,readSessions.
    [
      sessionId js,ws // 0
      user js,ws      // 1
      comKey js,ws    // 2
      "" js,ws        // 3 conId
      tm js,wi        // 4
      lapse js,wi     // 5
    ] data js,wa lst,push+
    this,writeSessions.
) addSession. =>

( sessionId =   // (String) -> Void
  this,readSessions.
    (js,ra !0 js,rs : sessionId : !=) lst,filter this,writeSessions.
) delSession. =>

( conId =; sessionId =   // (String, String) -> Void
  this,readSessions.
    ( SsJs =
      SsJs js,ra Ss =

      Ss !0 js,rs : sessionId : ==
      ( Ss : 3 : conId js,ws : lst,set+; js,wa)
      ( SsJs)
      elif
    ) lst,map this,writeSessions.
) setConnectionId. =>

// Public interface ------------------------------------------------------------

( @+:: this,Cgi. .home @-s)
home =>
/// @ -> @s
/// Returns 'home' directory.

( @+s:: k =;
  this,Cgi. : "key" : k wrap,some : map,put
@-) setKey =>
/// @s -> Void
/// Sets the key which 'cgi ok' and 'cgi err' will use. This function is called
/// when connection or authentication.

( @+s:: sessionId =
  sessionId this,klen cryp,genk this,setConnectionId.
  sessionId this,getSession
  ( )
  (
    {
      "key": "" js,ws
      "connectionId": "" js,ws
    } map,from
  )
  wrap,option
  this,ok
@-s) connect =>
/// @s -> @s
/// Returns client 'connectionId' and 'key'. If conection failed both are "".
///   session_id: Session identifier.
///   return    : JSON: {connectionId: String, key: String}.
///               'key' is a new key, set for the new connection.

( @+ssi:: expiration =; key =; user =
  user key this,checkUser.
  ( level =
    this,klen cryp,genk : sessionId =
    this,klen cryp,genk : key =
    sessionId : user : key
      expiration (this,Cgi. .tExpiration) (0) elif
      this,addSession.
    {
      "level": level js,ws
      "sessionId": sessionId js,ws
      "key": key js,ws
    } map,from
  )
  (
    {
      "level": "" js,ws
      "sessionId": "" js,ws
      "key": "" js,ws
    } map,from
  )
  wrap,option
  this,ok
@-s) authentication =>
/// @ssi -> @s
/// Sends to client level, key, page_id and session_id.
/// If authentication failed every value is "".
///   user      : User name.
///   key       : User password.
///   expiration: If is set to 0, session will expire after 30 days.
///   return    : JSON: {level: String, key: String, sessionId: String}

( @+s:: sessionId =
  time,now : now =

  this,readSessions.
    (js,ra !4 js,ri : now : >=) lst,filter
    ( SsJs =
      SsJs js,ra Ss =

      Ss !0 js,rs : sessionId : ==
      (
        Ss !5 : js,ri : lapse =
        Ss : 4 : time,now lapse time,add js,wi : lst,set+
        js,wa
      )
      ( SsJs)
      elif
    ) lst,map : Sessions =

  Sessions this,writeSessions.

  Sessions (js,ra !0 js,rs : sessionId : ==) lst,find
  ( Ss =
    {
      "key": Ss js,ra !2
      "connectionId": Ss js,ra !3
    } map,from wrap,some
  )
  ( wrap,none)
  wrap,option
@-o) getSession =>
/// @s -> @s
///   sesionId: Session identifier.
///   return  : [{key: Js, conId: Js} map,from] or [].

( @+s:: sessionId =
  this,readSessions.
    (js,ra !0 js,rs : sessionId : !=) lst,filter
    this,writeSessions.
    this,none
@-s) delSession =>
/// @s -> @s
/// Deletes 'sessionId' and returns an empty response.
///   sessionId: Session identifier
///   return: JSON: {}

( level =; ukey =; user =; akey =; admin =
  {} "ok"
    admin akey this,checkUser.
    ( "0" == (user ukey level this,putUser.; 1) (0) elif)
    ( 0)
    wrap,option
    js.wb map,put+ this,ok
) addUser =>

( user =; akey =; admin =
  {} "ok"
    admin akey this,checkUser.
    ( "0" == (user this,delUser.; 1) (0) elif)
    ( 0)
    wrap,option
    js.wb map,put+ this,ok
) delUser =>

( level =;user =; akey =; admin =
  {} "ok"
    admin akey this,checkUser.
    ( "0" == (user level this,changeLevel.; 1) (0) elif)
    ( 0)
    wrap,option
    js.wb map,put+ this,ok
) changeLevel =>

( @+sss:: this,changePass. r =; {} map,from "ok" r js,wb map,put+ this,ok @-s)
changePass =>
/// @sss -> @s
/// Changes user password.
///   user   : User name to change password.
///   key    : Old password.
///   new_key: New password.
///   return : JSON: {ok:true|false}, sets to true if operation
///            succeeded. A fail can come up if 'user' authentication fails.

( @+m
  js,wo
    this,Cgi. .key
    ( cryp,cryp)
    ( "Cgi has not been initialized")
    wrap,option
@-s) ok =>
/// @m -> @s
/// Returns an JSON of type object converted to string.

( @+
  {} map,from this,ok
@-s) none =>
/// @ -> @s
///   return: JSON: {}

( @+s:: msg =
  { "error": msg js,ws } map,from this,ok
@-s) error =>
/// @s -> @s
///   msg: Error message
///   return: JSON: {error: msg}

( @+
  { "expired": 1 js,wb } map,from this,ok
@-s) expired =>
/// @ -> @s
///   return: JSON: {expired: true}
